# src/holdem/io/cli.py

"""Command-line interface for the `holdem` package.

Examples
--------
$ holdem --version
$ holdem deal -n 6 --street flop
$ holdem deal -n 2 --street river --json
$ holdem eval --hand "As Kd" --board "Qc Jh 10h 9s 2d"

Notes
-----
- Uses only the Python standard library.
- Safe to import: all heavy work is behind subcommands.
- Designed to be extended with more subcommands later.

Entry point (pyproject.toml):
[project.scripts]
holdem = "holdem.io.cli:main"
"""
from __future__ import annotations


from dataclasses import asdict, is_dataclass
import argparse
import json
import sys
import textwrap
from typing import Iterable, List, Sequence


try: # Python ≥3.8
    from importlib.metadata import PackageNotFoundError, version as _pkg_version
except Exception: # pragma: no cover - extremely old Pythons
    from importlib_metadata import PackageNotFoundError, version as _pkg_version # type: ignore


# Package version (matches pattern you used elsewhere)
try:
    __version__ = _pkg_version("holdem")
except PackageNotFoundError:  # pragma: no cover - fallback for editable installs
    try:
        from ._version import version as __version__  # generated by setuptools_scm during sdist/bdist
    except Exception:
        __version__ = "0+unknown"

# Project imports kept lightweight and local to functions so `import holdem.cli`
# doesn't pull in the entire engine. Only enums/cards are imported at module level.
from ..core.enums import Rank, Suit
from ..core.cards import Card

# --- Card parsing / formatting helpers -------------------------------------
_RANK_STR_TO_ENUM = {**{str(n): getattr(Rank, name) for n, name in zip(range(2, 10), ["TWO",
                                                                                      "THREE",
                                                                                      "FOUR",
                                                                                      "FIVE",
                                                                                      "SIX",
                                                                                      "SEVEN",
                                                                                      "EIGHT",
                                                                                      "NINE"]
                                                                       )
                        },"10": Rank.TEN, "J": Rank.JACK, "Q": Rank.QUEEN, "K": Rank.KING, "A": Rank.ACE
                     }

_SUIT_STR_TO_ENUM = {
"S": Suit.SPADES,
"H": Suit.HEARTS,
"D": Suit.DIAMONDS,
"C": Suit.CLUBS,
}

def _parse_card(tok: str) -> Card:
    """Parse a token like 'As', 'Kd', '10h', 'tC' into a Card.
    Accepts optional whitespace and comma separators; case-insensitive.
    """
    t = tok.strip().replace("\u2660", "s").replace("\u2665", "h").replace("\u2666", "d").replace("\u2663", "c")
    if not t:
        raise ValueError("empty card token")

    t = t.lower()
    # allow formats: rs (e.g., 'as'), 10s, t s, etc.
    # Extract rank part
    if t.startswith("10"):
        r_part = "10"
        s_part = t[2:]
    else:
        r_part = t[0].upper()
        s_part = t[1:]

    if not s_part:
        raise ValueError(f"missing suit in token '{tok}'")

    suit_char = s_part[0].upper()
    try:
        rank = _RANK_STR_TO_ENUM[r_part]
    except KeyError as e:
        raise ValueError(f"invalid rank in token '{tok}'") from e

    try:
        suit = _SUIT_STR_TO_ENUM[suit_char]
    except KeyError as e:
        raise ValueError(f"invalid suit in token '{tok}'") from e

    return Card(rank=rank, suit=suit)

def _parse_cards_arg(arg: str) -> List[Card]:
    """Parse a string of cards separated by spaces or commas.
    Example: "As Kd", "As,Kd", "As, Kd".
    """
    parts = [p for p in (arg.replace("/", " ").replace("|", " ").replace(",", " ").split()) if p]
    if not parts:
        return []
    return [_parse_card(p) for p in parts]

def _card_compact(c: Card) -> str:
    """Return compact ASCII like 'As' instead of fancy symbols.
    Useful for JSON and plain console output.
    """
    rank_map = {Rank.TEN: "T", Rank.JACK: "J", Rank.QUEEN: "Q", Rank.KING: "K", Rank.ACE: "A"}
    r = str(c.rank.value) if 2 <= c.rank.value <= 9 else rank_map.get(c.rank, "?")
    return f"{r}{c.suit.value}" # Suit.StrEnum has values 's','h','d','c'

def _cards_compact(cards: Iterable[Card]) -> List[str]:
    return [_card_compact(c) for c in cards]

# --- Subcommand implementations --------------------------------------------

def _cmd_version(_: argparse.Namespace) -> int:
    print(__version__)
    return 0

def _cmd_deal(ns: argparse.Namespace) -> int:
    import random

    num_players: int = ns.num_players
    street: str = ns.street
    seed: int | None = ns.seed
    as_json: bool = ns.json

    if num_players < 2 or num_players > 10:
        print("error: --num-players must be in [2, 10]", file=sys.stderr)
        return 2

    street_to_board = {"preflop": 0, "flop": 3, "turn": 4, "river": 5}
    board_n = street_to_board[street]

    # Build a full deck lazily
    full_deck: List[Card] = [Card(rank=r, suit=s) for s in Suit for r in Rank]

    rng = random.Random(seed)
    needed = num_players * 2 + board_n
    if needed > len(full_deck): # pragma: no cover - defensive
        print("error: not enough cards to deal", file=sys.stderr)
        return 2

    picked = rng.sample(full_deck, k=needed)
    hole = picked[: num_players * 2]
    board = picked[num_players * 2 :]

    players = [hole[i : i + 2] for i in range(0, len(hole), 2)]

    # Split board by streets
    flop: Sequence[Card] = board[:3] if board_n >= 3 else []
    turn: Sequence[Card] = board[3:4] if board_n >= 4 else []
    river: Sequence[Card] = board[4:5] if board_n >= 5 else []

    if as_json:
        payload = {
        "street": street,
        "players": [{"seat": i + 1, "hand": _cards_compact(p)} for i, p in enumerate(players)],
        "board": {
        "flop": _cards_compact(flop),
        "turn": _cards_compact(turn),
        "river": _cards_compact(river),
        },
        "seed": seed,
        }
        print(json.dumps(payload, indent=2))
        return 0

    # Human-readable
    print(f"Players: {num_players} | Street: {street} | Seed: {seed}")
    for i, p in enumerate(players, start=1):
        print(f"P{i:>2}: {' '.join(_cards_compact(p))}")


    if board_n:
        if flop:
            print(f"Flop : {' '.join(_cards_compact(flop))}")
        if turn:
            print(f"Turn : {' '.join(_cards_compact(turn))}")
        if river:
            print(f"River: {' '.join(_cards_compact(river))}")
    return 0




def _cmd_eval(ns: argparse.Namespace) -> int:
    # Import here so CLI stays import-light if user never calls `eval`.
    try:
        from holdem.core.evaluator import evaluate_player_hand # type: ignore
    except Exception as e: # pragma: no cover - evaluator may not exist yet
        print(
            "error: evaluator not available (holdem.core.evaluator.evaluate_player_hand).\n"
            f"Import error was: {e}",
            file=sys.stderr,
        )
        return 2

    try:
        hole_cards = _parse_cards_arg(ns.hand)
        if len(hole_cards) != 2:
            raise ValueError("--hand must contain exactly two cards, e.g. 'As Kd'")
        board_cards = _parse_cards_arg(ns.board) if ns.board else []
        if len(board_cards) not in {0, 3, 4, 5}:
            raise ValueError("--board must be 0, 3, 4, or 5 cards")
    except ValueError as ve:
        print(f"error: {ve}", file=sys.stderr)
        return 2

    # Evaluate
    try:
        result = evaluate_player_hand(tuple(hole_cards), tuple(board_cards))  # type: ignore[arg-type]
    except TypeError:
        # Some versions might expect lists rather than tuples – try again
        result = evaluate_player_hand(hole_cards, board_cards)  # type: ignore[misc]

    # Try to normalize a few likely return shapes
    rank_name: str | None = None
    best_cards: Sequence[Card] | None = None
    extra: dict | None = None

    # 1) Dataclass with fields (hand_rank, best_five, ...)
    if is_dataclass(result):
        d = asdict(result)
        # Look for common keys
        for key in ("hand_rank", "rank", "hand", "handrank"):
            v = d.get(key)
            if hasattr(v, "name"):
                rank_name = getattr(v, "name")
                break
            if isinstance(v, str):
                rank_name = v
                break
        for key in ("best_five", "best", "cards", "made_hand"):
            v = d.get(key)
            if isinstance(v, list) and v and isinstance(v[0], Card):
                best_cards = v
                break
        extra = d

    # 2) Tuple like (HandRank, [Card, ...])
    if rank_name is None and isinstance(result, tuple) and result:
        first = result[0]
        if hasattr(first, "name"):
            rank_name = getattr(first, "name")
    # try to find a list of Cards in the tuple
    for item in result:
        if isinstance(item, list) and item and isinstance(item[0], Card):
            best_cards = item
            break

    # 3) Object with attributes (hand_rank, best_five, ...)
    if rank_name is None and hasattr(result, "hand_rank"):
        hr = getattr(result, "hand_rank")
        rank_name = getattr(hr, "name", str(hr))
    if best_cards is None and hasattr(result, "best_five"):
        best_cards = getattr(result, "best_five")

    # Fallbacks
    if rank_name is None:
        rank_name = str(result)

    if ns.json:
        payload = {
            "hand": _cards_compact(hole_cards),
            "board": _cards_compact(board_cards),
            "rank": rank_name,
            "best": _cards_compact(best_cards or []),
        }
        print(json.dumps(payload, indent=2))
        return 0

    print(f"Hand : {' '.join(_cards_compact(hole_cards))}")
    if board_cards:
        if len(board_cards) >= 3:
            print(f"Flop : {' '.join(_cards_compact(board_cards[:3]))}")
        if len(board_cards) >= 4:
            print(f"Turn : {' '.join(_cards_compact(board_cards[3:4]))}")
        if len(board_cards) == 5:
            print(f"River: {' '.join(_cards_compact(board_cards[4:5]))}")
    print(f"Rank : {rank_name}")
    if best_cards:
        print(f"Best : {' '.join(_cards_compact(best_cards))}")
    return 0

# --- Parser setup -----------------------------------------------------------

def _build_parser() -> argparse.ArgumentParser:
    epilog = textwrap.dedent(
        """
        Card notation
        - Ranks: 2..9, T (or 10), J, Q, K, A
        - Suits: s, h, d, c (spades/hearts/diamonds/clubs)
        - Examples: As Kd, 10h, Qc
        """
    ).strip()

    p = argparse.ArgumentParser(
        prog="holdem",
        description="Command-line utilities for the holdem engine",
        epilog=epilog,
        formatter_class=argparse.RawTextHelpFormatter,
    )

    p.add_argument(
    "-V", "--version", action="version", version=f"holdem {__version__}", help="show version and exit"
    )

    sub = p.add_subparsers(dest="command", required=True)

    # version (explicit subcommand, in addition to -V/--version)
    sp_ver = sub.add_parser("version", help="print version and exit")
    sp_ver.set_defaults(func=_cmd_version)

    # deal
    sp_deal = sub.add_parser("deal", help="deal random hands and optional board")
    sp_deal.add_argument("-n", "--num-players", type=int, default=6, help="number of players (2-10)")
    sp_deal.add_argument("--street",
                         choices=("preflop", "flop", "turn", "river"),
                         default="flop",
                         help="how many board cards to show",
    )
    sp_deal.add_argument("--seed", type=int, default=None, help="random seed for reproducibility")
    sp_deal.add_argument("--json", action="store_true", help="output JSON instead of text")
    sp_deal.set_defaults(func=_cmd_deal)

    # eval
    sp_eval = sub.add_parser("eval", help="evaluate a hand against a board")
    sp_eval.add_argument("--hand", required=True, help="two cards, e.g. 'As Kd'")
    sp_eval.add_argument("--board", default="", help="0/3/4/5 cards, e.g. 'Qc Jh 10h 9s 2d'")
    sp_eval.add_argument("--json", action="store_true", help="output JSON instead of text")
    sp_eval.set_defaults(func=_cmd_eval)

    return p

def main(argv: Sequence[str] | None = None) -> int:
    parser = _build_parser()
    ns = parser.parse_args(list(argv) if argv is not None else None)
    return ns.func(ns)

if __name__ == "__main__": # pragma: no cover
    sys.exit(main())

